/*

#Slightly modified problem description:
-use 0 indexing for everything
-sellers are identified by a letter, customers by integer id
-more specific on how seat fill ordering should happen taking various cases into account
-we make "1 minute" be 64 milliseconds(msec) in program execution time.

There are 10 by 10 seats as a 1d array[100]

Sellers reserve a seat (begin sync), marking it occupied (end sync). Then the seller must
do some kind of work, sleeping for some time.

Each seller has N customers each, they may have to sleep until the next customers arrival time before serving.
Make N<100 for printing purposes

There are 3 selling start positions, and 2 gaps that shrink at both ends each.

Only 1 seller is H service, starts selling at position=0 and increments up.
Serves in 1-2 minutes. If top 'x' gap becomes full, use same strategy below:

3 are Mid sellers, serve in 2-4 minutes. Their pos sequence is 50,49,51,52...
If the upper 'x' gap fills up, they would then start selling incrementing from
the smallest index unsold, incrementing up. If this gap then becomes full, concert is at max capacity.

Similar logic if lower 'y' gap becomes full first.

6 are low-price sellers, they are like the high seller, but there are multiple of them and
they start at i=99 and decrement down. 4-7 minutes

"MB01" means: slot sold to Mid seller B's customer 1

HA00 HA01 HA02 HA03
HA00 HA01 xxxx xxxx
xxxx ...
xxxx xxxx xxxx MC01
MA01 MC00 MA00 MB00
MB01 yyyy ...
yyyy LB00 LA00 LB00

How simulation ends:

"
At the end of one hour[60 time units], each ticket seller should complete whatever purchase may
still be in progress and close the ticket window. Any remaining customers in the
queues should leave immediately. Of course, if the concert sells out before the hour
is up, all the ticket windows should close after the last seat is taken.
"

Each thread builds up its own history of transactions, and all are reported at the end
(see program output).

As an exercise with using condition variables (and to have relative time of arrival?),
all threads start at close to the same time before they can service any customer.
This is done once at the start.

#Program output
These are events to be reported, list in order of their occurrence an event is:
-A customer arrives at the tail of a sellerâ€™s queue.
-A customer is served and is assigned a seat, or is told the concert is sold out,
in which case the customer immediately leaves (how about that customer tells everyone behind him too?).
-A customer completes a ticket purchase and leaves.

After that, print the final matrix.

#Synchronization strategy/thoughts

Just have a single spin-lock to access the whole damn thing, or maybe 2, one for each gap area.
Threads take a lot of time to service customer on their own, so should not expect
much lock contention. Lock is only held for the time it takes to load and store a few integers most of the time.

#Implementation notes
-Use of function pointers for slick state changes and seller code use

*/
